// Generated by skate
// DO NOT EDIT MANUALLY

// ============================================
// Types
// ============================================
import type { Article, NewsletterSubscriber } from '@prisma/client';

export type ArticlesResponse = Article[];

export type LatestArticlesResponse = Article[];

export type ArticleResponse = Article;

export interface NewsletterResponse {
  success: boolean;
  subscriber: NewsletterSubscriber;
}

// ============================================
// Error Handling
// ============================================

export type Result<T, E = Error> =
	| { success: true; data: T }
	| { success: false; error: E };

export class ApiError extends Error {
	constructor(
		message: string,
		public status: number,
		public statusText: string,
		public body?: unknown
	) {
		super(message);
		this.name = 'ApiError';
	}
}

// ============================================
// Utility Types
// ============================================

interface QueryValidationSchema {
	required?: string[];
	fields?: Record<string, { type: string; required?: boolean }>;
}

function validateQueryParams<T>(
	params: T | undefined,
	schema?: QueryValidationSchema
): { valid: boolean; error?: string } {
	if (!params) {
		if (schema?.required && schema.required.length > 0) {
			return { valid: false, error: `Missing required parameters: ${schema.required.join(', ')}` };
		}
		return { valid: true };
	}

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const paramsObj = params as Record<string, any>;

	// Check required fields
	if (schema?.required) {
		for (const field of schema.required) {
			if (paramsObj[field] === undefined || paramsObj[field] === null) {
				return { valid: false, error: `Missing required parameter: ${field}` };
			}
		}
	}

	// Check field types
	if (schema?.fields) {
		for (const [field, def] of Object.entries(schema.fields)) {
			const value = paramsObj[field];
			if (value !== undefined && value !== null) {
				const actualType = typeof value;
				if (def.type === 'number' && actualType !== 'number') {
					return { valid: false, error: `Parameter '${field}' must be a number` };
				}
				if (def.type === 'boolean' && actualType !== 'boolean') {
					return { valid: false, error: `Parameter '${field}' must be a boolean` };
				}
			}
		}
	}

	return { valid: true };
}

function buildQueryString<T>(
	params?: T,
	schema?: QueryValidationSchema
): string {
	if (!params) return '';

	// Validate parameters
	if (schema) {
		const validation = validateQueryParams(params, schema);
		if (!validation.valid) {
			console.error('[API Client]', validation.error);
			// Continue building query string even on validation error
		}
	}

	const entries = Object.entries(params)
		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		.filter(([_, value]) => value !== undefined && value !== null)
		.map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);

	return entries.length > 0 ? `?${entries.join('&')}` : '';
}

interface BodyValidationSchema {
	required?: string[];
	fields?: Record<string, { type: string; required?: boolean }>;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type ZodSchema = { safeParse: (data: any) => { success: boolean; error?: { issues: any[] } } };

function validateBody<T>(
	body: T,
	schemaOrZod?: BodyValidationSchema | ZodSchema
): { valid: boolean; error?: string } {
	if (!body) {
		// Check if it's a regular schema with required fields
		if (schemaOrZod && 'required' in schemaOrZod && schemaOrZod.required && schemaOrZod.required.length > 0) {
			return { valid: false, error: `Missing required fields: ${schemaOrZod.required.join(', ')}` };
		}
		return { valid: true };
	}

	// Check if it's a Zod schema
	if (schemaOrZod && 'safeParse' in schemaOrZod) {
		const result = schemaOrZod.safeParse(body);
		if (!result.success) {
			const errors = result.error?.issues.map(i => i.message).join(', ') || 'Validation failed';
			return { valid: false, error: errors };
		}
		return { valid: true };
	}

	const schema = schemaOrZod as BodyValidationSchema | undefined;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const bodyObj = body as Record<string, any>;

	// Check required fields
	if (schema?.required) {
		for (const field of schema.required) {
			if (bodyObj[field] === undefined || bodyObj[field] === null) {
				return { valid: false, error: `Missing required field: ${field}` };
			}
		}
	}

	// Check field types
	if (schema?.fields) {
		for (const [field, def] of Object.entries(schema.fields)) {
			const value = bodyObj[field];
			if (value !== undefined && value !== null) {
				const actualType = typeof value;
				let isValid = false;

				switch (def.type) {
					case 'string':
						isValid = actualType === 'string';
						break;
					case 'number':
						isValid = actualType === 'number' && !isNaN(value as number);
						break;
					case 'boolean':
						isValid = actualType === 'boolean';
						break;
					case 'object':
						isValid = actualType === 'object' && !Array.isArray(value);
						break;
					case 'array':
						isValid = Array.isArray(value);
						break;
					default:
						isValid = true;
				}

				if (!isValid) {
					return { valid: false, error: `Field '${field}' must be a ${def.type}` };
				}
			}
		}
	}

	return { valid: true };
}

// ============================================
// HTTP Client
// ============================================

async function fetchApi<T>(
	url: string,
	options?: RequestInit
): Promise<Result<T, ApiError>> {
	try {
		const response = await fetch(url, {
			...options,
			headers: {
				'Content-Type': 'application/json',
				...options?.headers
			}
		});

		if (!response.ok) {
			const errorBody = await response.text().catch(() => null);
			return {
				success: false,
				error: new ApiError(
					`HTTP ${response.status}: ${response.statusText}`,
					response.status,
					response.statusText,
					errorBody
				)
			};
		}

		const data = await response.json() as T;
		return { success: true, data };
	} catch (error) {
		return {
			success: false,
			error: new ApiError(
				error instanceof Error ? error.message : 'Unknown error',
				0,
				'Network Error',
				error
			)
		};
	}
}

// ============================================
// API Client
// ============================================

export const api = {
  articles: Object.assign(
    // Dynamic route function
    (slug: string | number) => ({
      /**
       * GET /api/articles/${slug}
       * 
       * @param {string|number} slug - Path parameter for the resource ID
       * 
       * @returns {Promise<Result<Article, ApiError>>} Result object with data or error
       * 
       * @example
       * const result = await api.articles(slug).get();
       * if (result.success) {
       *   console.log(result.data);
       * } else {
       *   console.error(result.error);
       * }
       */
      get: async () => {
        return fetchApi<Article>(
          `/api/articles/${slug}`,
          { method: 'GET' }
        );
      },
    }),
    // Static route methods
    {
      /**
       * GET /api/articles
       * 
       * 
       * @returns {Promise<Result<Article[], ApiError>>} Result object with data or error
       * 
       * @example
       * const result = await api.articles.get();
       * if (result.success) {
       *   console.log(result.data);
       * } else {
       *   console.error(result.error);
       * }
       */
      get: async () => {
        return fetchApi<Article[]>(
          '/api/articles',
          { method: 'GET' }
        );
      },
    }
  ),
  articles_latest: {
      /**
       * GET /api/articles/latest
       * 
       * 
       * @returns {Promise<Result<Article[], ApiError>>} Result object with data or error
       * 
       * @example
       * const result = await api.articles.latest.get();
       * if (result.success) {
       *   console.log(result.data);
       * } else {
       *   console.error(result.error);
       * }
       */
      get: async () => {
        return fetchApi<Article[]>(
          '/api/articles/latest',
          { method: 'GET' }
        );
      },
  },
  newsletter: {
      /**
       * POST /api/newsletter
       * 
       * @param {unknown} body - Request body
       * 
       * @returns {Promise<Result<NewsletterResponse, ApiError>>} Result object with data or error
       * 
       * @example
       * const result = await api.newsletter.post(body);
       * if (result.success) {
       *   console.log(result.data);
       * } else {
       *   console.error(result.error);
       * }
       */
      post: async (body: unknown) => {
        return fetchApi<NewsletterResponse>(
          '/api/newsletter',
          { method: 'POST', body: JSON.stringify(body) }
        );
      },
  },
} as const;
